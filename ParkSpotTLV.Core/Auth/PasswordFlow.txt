Imagine:

You’re building the security guard booth at the entrance of a building (our app).

Step 1 — Passwords (Argon2id)

When someone registers, they give a password.

We don’t keep their password. Instead, we scramble it with Argon2id (a very strong blender) plus some salt, and we store only the scrambled result.

Later, when they log in, we take the password they typed, scramble it the same way, and check if the scrambled result matches.

If yes → it’s them. If not → reject.

The “boot-time calibration” is us testing how fast the blender should run so it’s slow enough to block hackers but fast enough for real users.

Files:
IPasswordHasher
Argon2PasswordHasher + Argon2Options

Step 2 — JWT (Short Life Access Token)

When login succeeds, we hand them a temporary badge (the JWT).

That badge says:

Who they are (sub = their ID).

Their name.

When it was issued.

When it expires (soon).

Who issued it (our system).

They wear this badge whenever they walk around inside the building (make API calls).

After a short time (like 10 minutes), the badge expires → they need a new one.

Files:
IJwtService + JwtService
AuthOptions

Step 3 — Refresh Token (long-lived session management)

To avoid asking them to re-login every 10 minutes, we give them a longer-lasting secret key (the refresh token).

They keep this hidden in their pocket (app storage).

When the short badge (JWT) expires, they show us the refresh token:

If it’s still good, we:

Give them a new badge (new JWT).

Also give them a new refresh token and take away the old one.

If they try to use the old refresh token again → red flag! Someone might have stolen it. We cancel the whole session chain (kick them out everywhere).

Files:
IRefreshTokenService
RefreshTokenService
TokenHashing
RefreshTokens + RefreshTokensConfig
EfRefreshTokenStore
AuthOptions

“Flow”:

1. Register

Normalize username → run password policy checks.

Hash password with Argon2id (per-user salt, calibrated to ~100–250 ms).

Save user with PasswordHash (and salt if stored separately).

2. Login

Normalize username → fetch user.

Verify password with Argon2id (constant-time result).

On success:

Issue access token (JWT) via JwtService.IssueAccessToken(userId, username)

Issue refresh token via RefreshTokenService.Issue(userId) (store hash, return raw to client).

3. Refresh

Client sends raw refresh token.

ValidateAndRotate: check hash, expiry, revocation; reuse detection → if old token is reused, revoke the chain.

Rotate: mark old revoked + create new refresh token; also issue a new JWT.

4. Logout

Revoke the single session by raw token, or all sessions for the user.